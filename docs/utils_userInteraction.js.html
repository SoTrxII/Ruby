<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: utils/userInteraction.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: utils/userInteraction.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @async
 * @public
 * @summary Wait
 for a user to post a valid message
 * @param {String} authorId who are we waiting for ?
 * @param {Function} validation is the given message valid ? Returns True or False
 * @param {Integer} timeout Reject automatically after a certain time (-1 for infinite)
 * @returns {Promise&lt;String>} Resolve with the message the user sent.
 */
function waitForMessage (authorId, validation, timeout) {
    return new Promise((resolve, reject) => {
        if(timeout != -1){
            setTimeout( () => {
                reject("Timeout")
            }, timeout)
        }
        let func = (message) => {
            if (message.author.id == authorId) {
                if (validation(message.content, message)) {
                    global.Rin.off('message', func);
                    resolve(message);
                }
            }
        };
        global.Rin.on('message', func);
     });
}

/**
 * @async
 * @public
 * @summary Ask a user a yes / no question
 * @param {Discordjs/Message} evt General handle to text channel
 * @param {Discordjs/User_id} authorId Id of the one user that has to answer 
 * @param {String} question question to ask
 * @param {Integer} timeout timeout for the question. (Default is 5') Null is then returned.
 * @returns {Promise&lt;Boolean>} true for yes, false for no, null if timeout
 */
async function yesNoQuestion(evt, authorId, question, timeout){
    evt.reply(`${question} [O/n]`)
    let message = await waitForMessage(authorId, (message) => {
        const validResponses = ['O', 'o', 'n', 'N', 'Oui', 'Non', 'oui', 'non'];
        if(validResponses.includes(message)){
            return true;
        }else {
            evt.reply("C'est oui ou non...");
            return false
    }

    },timeout || 5*60*1000).catch(ex => {return null});
    let positiveAnswers = ['O', 'o', 'Oui', 'oui'];
    return positiveAnswers.includes(message.content)

}
/**
 * @summary Make the user choose between the choices in itemList
 * @param {Discordjs/Message} evt General handle to text channel
 * @param {Object[]} itemList Choices. Each choice has to have a .toString() method
 * @param {String} question Question to ask the user
 * @param {Object} [options] optional parameters
 * @param {String} options.noItemResponse what to repy itemList is empty (nothing if undefined)
 * @param {Integer} options.timeout timeout for the question. (Default is 5') Null is then returned.
 * @param {Boolean} [options.displayChoices=true] Whether to display the choices 
 * @returns {Promise&lt;Object>} chosen item or null if no item, stopped or timeout
 */
async function chooseOneItem(evt, itemList, question, options){
    if (itemList.length == 0) {
        if(options.noItemResponse){
            evt.reply(options.noItemResponse)
        }
        return null;
    }
    else if (itemList.length == 1) {
        chosenItem = itemList[0];
        return chosenItem
    } else {

        choicestring = `${question} (staph pour annuler) \n`

        if (options.displayChoices){
            for (let [index, campaign] of itemList.entries()) {
                choicestring += `\t\t**${index + 1}**)\t-->\t`
                choicestring += await campaign.toString()
            }
        }

        evt.channel.send(choicestring)
        let choice = await waitForMessage(evt.author.id, (message) => {
            if (message == "staph") {
                return true;
            }
            let choice = parseInt(message);
            if (choice > itemList.length || choice &lt; 1) {
                evt.reply(`Je te dis entre 1 et ${itemList.length} et tu me réponds ${choice}...`)
                return false;
            } else if (isNaN(choice) || !isFinite(choice)) {
                evt.reply(`Numbers, do you speak it ? Try again !`)
                return false;
            } else {
                return true;
            }

        }, options.timeout || 5 * 60 * 100).catch(ex => {return null});

        if (choice.content == 'staph') {
            evt.channel.send("Annulé !")
            return null;
        }
        chosenItem = itemList[(parseInt(choice.content) - 1)];

        return chosenItem
    }
}


module.exports = {
    waitForMessage : waitForMessage,
    chooseOneItem: chooseOneItem,
    yesNoQuestion: yesNoQuestion
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-parseTextCommand.html">parseTextCommand</a></li></ul><h3>Classes</h3><ul><li><a href="Jukebox.html">Jukebox</a></li><li><a href="JukeboxFanburstItem.html">JukeboxFanburstItem</a></li><li><a href="JukeboxItem.html">JukeboxItem</a></li><li><a href="JukeboxLocalItem.html">JukeboxLocalItem</a></li><li><a href="JukeboxOpeningmoeItem.html">JukeboxOpeningmoeItem</a></li><li><a href="JukeboxYoutubeItem.html">JukeboxYoutubeItem</a></li></ul><h3>Events</h3><ul><li><a href="Jukebox.html#event:QueueEmpty">QueueEmpty</a></li><li><a href="JukeboxFanburstItem.html#event:end">end</a></li><li><a href="JukeboxItem.html#event:end">end</a></li><li><a href="JukeboxLocalItem.html#event:end">end</a></li><li><a href="JukeboxOpeningmoeItem.html#event:end">end</a></li><li><a href="JukeboxYoutubeItem.html#event:end">end</a></li></ul><h3>Global</h3><ul><li><a href="global.html#_supportedSources">_supportedSources</a></li><li><a href="global.html#addToQueue">addToQueue</a></li><li><a href="global.html#asker">asker</a></li><li><a href="global.html#blindTest">blindTest</a></li><li><a href="global.html#chooseOneItem">chooseOneItem</a></li><li><a href="global.html#displayMessage">displayMessage</a></li><li><a href="global.html#exitHandler">exitHandler</a></li><li><a href="global.html">expiration</a></li><li><a href="global.html#getMember">getMember</a></li><li><a href="global.html#hasBegun">hasBegun</a></li><li><a href="global.html#infos">infos</a></li><li><a href="global.html#isBlindTest">isBlindTest</a></li><li><a href="global.html#isPaused">isPaused</a></li><li><a href="global.html#isPlaying">isPlaying</a></li><li><a href="global.html#list">list</a></li><li><a href="global.html">openingListUpdateDate</a></li><li><a href="global.html#pause">pause</a></li><li><a href="global.html#play">play</a></li><li><a href="global.html#replyRandom">replyRandom</a></li><li><a href="global.html#restart">restart</a></li><li><a href="global.html#resume">resume</a></li><li><a href="global.html#sandwich">sandwich</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#saveConfig">saveConfig</a></li><li><a href="global.html#saveDatabaseConfig">saveDatabaseConfig</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#setVolume">setVolume</a></li><li><a href="global.html#skip">skip</a></li><li><a href="global.html#stop">stop</a></li><li><a href="global.html#textChannel">textChannel</a></li><li><a href="global.html#track">track</a></li><li><a href="global.html#voiceConnection">voiceConnection</a></li><li><a href="global.html#volume">volume</a></li><li><a href="global.html#waitForMessage">waitForMessage</a></li><li><a href="global.html#yesNoQuestion">yesNoQuestion</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Jul 15 2018 14:20:18 GMT+0200 (GMT+02:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
